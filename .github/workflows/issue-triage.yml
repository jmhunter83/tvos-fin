name: Issue Triage with Claude
# Triggered when issues are opened or when labels are added

on:
  issues:
    types: [opened, labeled]

permissions:
  issues: write

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage Issue with Claude
        uses: actions/github-script@v7
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          # Using github-script which handles inputs safely through JavaScript
          # (not shell interpolation) - see https://github.com/actions/github-script
          script: |
            const issue = context.payload.issue;
            const title = issue.title;
            const body = issue.body || '';
            const action = context.payload.action;
            const labelAdded = context.payload.label?.name;

            // Get existing labels
            const existingLabels = issue.labels.map(l => l.name);
            const hasTriageLabels = existingLabels.some(l =>
              l.startsWith('severity:') || l.startsWith('area:') || l.startsWith('type:')
            );

            // Determine mode: 'new' for opened issues, 'review' for labeled issues
            const isReviewMode = action === 'labeled';

            // For review mode: skip if bot added the label (avoid loops)
            if (isReviewMode) {
              // Skip if this label was added by github-actions bot
              if (context.payload.sender?.login === 'github-actions[bot]') {
                console.log('Label added by bot, skipping to avoid loop');
                return;
              }
              // Only review if user added a triage label
              const isTriageLabel = labelAdded?.startsWith('severity:') ||
                                    labelAdded?.startsWith('area:') ||
                                    labelAdded?.startsWith('type:');
              if (!isTriageLabel) {
                console.log('Non-triage label added, skipping review');
                return;
              }
              console.log(`Review mode: user added "${labelAdded}"`);
            } else {
              // New issue mode: skip if already has triage labels
              if (hasTriageLabels) {
                console.log('Issue already triaged, skipping');
                return;
              }
              console.log('New issue mode: auto-triaging');
            }

            // Available labels
            const severityLabels = ['severity: critical', 'severity: high', 'severity: medium', 'severity: low'];
            const areaLabels = ['area: playback', 'area: library', 'area: ui', 'area: auth', 'area: sync', 'area: settings'];
            const typeLabels = ['type: crash', 'type: regression', 'type: performance'];

            const prompt = [
              'You are a triage assistant for Reefy, a tvOS Jellyfin media player app.',
              '',
              'Analyze this GitHub issue and suggest appropriate labels.',
              '',
              'ISSUE TITLE: ' + title,
              '',
              'ISSUE BODY:',
              body,
              '',
              'FIRST, determine if this is a BUG or a FEATURE REQUEST:',
              '- Feature requests ask for NEW functionality, improvements, or enhancements',
              '- Bugs report BROKEN or incorrect behavior in existing functionality',
              '',
              'Respond with a JSON object containing:',
              '',
              '1. "issueType": one of [bug, feature_request]',
              '   - bug: Something is broken or not working correctly',
              '   - feature_request: Request for new functionality or enhancement',
              '',
              '2. "severity": one of [critical, high, medium, low, null]',
              '   ONLY for bugs! Set to null for feature requests.',
              '   - critical: App crash, data loss, security issue',
              '   - high: Major feature broken, no workaround',
              '   - medium: Feature impaired, workaround exists',
              '   - low: Minor issue, cosmetic',
              '',
              '3. "area": one of [playback, library, ui, auth, sync, settings, other]',
              '   - playback: Video/audio codec issues, streaming, buffering, transcoding, subtitles during playback',
              '   - library: Media browsing, search, collections, Up Next queue',
              '   - ui: Focus, navigation, layout, buttons, visual display, remote input, scrolling',
              '   - auth: Authentication, server connection',
              '   - sync: Downloads, offline content',
              '   - settings: Preferences, configuration',
              '',
              'NOTE: Focus/navigation issues WITHIN the video player are "ui", not "playback".',
              'Playback issues are about the actual video/audio stream, codecs, buffering - not player UI controls.',
              '',
              '4. "type": one of [crash, regression, performance, null]',
              '   ONLY for bugs! Set to null for feature requests.',
              '   - crash: App crashes or freezes',
              '   - regression: Previously worked, now broken',
              '   - performance: Slow, laggy, resource intensive',
              '',
              '5. "confidence": number 0-100 indicating how confident you are',
              '',
              '6. "reasoning": brief explanation (1-2 sentences)',
              '',
              'Respond ONLY with valid JSON, no other text.'
            ].join('\n');

            try {
              const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.ANTHROPIC_API_KEY,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-3-haiku-20240307',
                  max_tokens: 256,
                  messages: [{
                    role: 'user',
                    content: prompt
                  }]
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
              }

              const data = await response.json();
              const content = data.content[0].text;
              const analysis = JSON.parse(content);

              console.log('Claude analysis:', analysis);

              // Build correct labels based on analysis
              const correctLabels = [];
              const isFeatureRequest = analysis.issueType === 'feature_request';

              if (isFeatureRequest) {
                correctLabels.push('enhancement');
              } else {
                if (analysis.severity && severityLabels.includes(`severity: ${analysis.severity}`)) {
                  correctLabels.push(`severity: ${analysis.severity}`);
                }
                if (analysis.type && typeLabels.includes(`type: ${analysis.type}`)) {
                  correctLabels.push(`type: ${analysis.type}`);
                }
              }
              if (analysis.area && analysis.area !== 'other' && areaLabels.includes(`area: ${analysis.area}`)) {
                correctLabels.push(`area: ${analysis.area}`);
              }

              // REVIEW MODE: Check if user's labels need correction
              if (isReviewMode) {
                // Only correct if confidence >= 80 (higher bar for corrections)
                if (analysis.confidence < 80) {
                  console.log(`Confidence ${analysis.confidence}% too low for correction, skipping`);
                  return;
                }

                // Find labels to remove and add
                const userTriageLabels = existingLabels.filter(l =>
                  l.startsWith('severity:') || l.startsWith('area:') || l.startsWith('type:')
                );
                const labelsToRemove = userTriageLabels.filter(l => !correctLabels.includes(l));
                const labelsToAdd = correctLabels.filter(l => !existingLabels.includes(l));

                // Only act if there's something to correct
                if (labelsToRemove.length === 0 && labelsToAdd.length === 0) {
                  console.log('User labels are correct, no changes needed');
                  return;
                }

                // Remove incorrect labels
                for (const label of labelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }

                // Add correct labels
                if (labelsToAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: labelsToAdd
                  });
                }

                console.log(`Corrected labels - removed: [${labelsToRemove.join(', ')}], added: [${labelsToAdd.join(', ')}]`);

                // Comment explaining the correction
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `ðŸ¤– **Label correction** (confidence: ${analysis.confidence}%)\n\n` +
                        (labelsToRemove.length > 0 ? `Removed: ${labelsToRemove.map(l => `\`${l}\``).join(', ')}\n` : '') +
                        (labelsToAdd.length > 0 ? `Added: ${labelsToAdd.map(l => `\`${l}\``).join(', ')}\n` : '') +
                        `\n${analysis.reasoning}`
                });
                return;
              }

              // NEW ISSUE MODE: Apply labels if confidence >= 70
              if (analysis.confidence < 70) {
                console.log(`Low confidence (${analysis.confidence}%), suggesting instead of applying`);
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `ðŸ¤– **Auto-triage suggestion** (confidence: ${analysis.confidence}%)\n\n` +
                        `- Type: \`${isFeatureRequest ? 'Feature Request' : 'Bug'}\`\n` +
                        (isFeatureRequest ? '' : `- Severity: \`${analysis.severity}\`\n`) +
                        `- Area: \`${analysis.area}\`\n` +
                        (analysis.type && !isFeatureRequest ? `- Bug Type: \`${analysis.type}\`\n` : '') +
                        `\n${analysis.reasoning}\n\n` +
                        `*Low confidence - labels not auto-applied. Please review and apply manually.*`
                });
                return;
              }

              if (correctLabels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: correctLabels
                });

                console.log(`Applied labels: ${correctLabels.join(', ')}`);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `ðŸ¤– **Auto-triaged** as ${isFeatureRequest ? 'Feature Request' : 'Bug'} (confidence: ${analysis.confidence}%)\n\n` +
                        `Applied labels: ${correctLabels.map(l => `\`${l}\``).join(', ')}\n\n` +
                        `${analysis.reasoning}`
                });
              }

            } catch (error) {
              console.error('Triage failed:', error.message);
              // Don't fail the workflow, just log the error
            }
